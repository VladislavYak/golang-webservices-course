
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>redditclone: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/VladislavYak/redditclone/cmd/redditclone/main.go (0.0%)</option>
				
				<option value="file1">github.com/VladislavYak/redditclone/mocks/auth_repository_mock.go (62.5%)</option>
				
				<option value="file2">github.com/VladislavYak/redditclone/mocks/comment_repository_mock.go (100.0%)</option>
				
				<option value="file3">github.com/VladislavYak/redditclone/mocks/post_repository_mock.go (100.0%)</option>
				
				<option value="file4">github.com/VladislavYak/redditclone/mocks/user_repository_mock.go (100.0%)</option>
				
				<option value="file5">github.com/VladislavYak/redditclone/pkg/application/auth.go (0.0%)</option>
				
				<option value="file6">github.com/VladislavYak/redditclone/pkg/application/comment.go (94.1%)</option>
				
				<option value="file7">github.com/VladislavYak/redditclone/pkg/application/post.go (98.5%)</option>
				
				<option value="file8">github.com/VladislavYak/redditclone/pkg/application/user.go (71.0%)</option>
				
				<option value="file9">github.com/VladislavYak/redditclone/pkg/domain/auth/token_generator.go (80.0%)</option>
				
				<option value="file10">github.com/VladislavYak/redditclone/pkg/domain/comment/comment.go (0.0%)</option>
				
				<option value="file11">github.com/VladislavYak/redditclone/pkg/domain/post/post.go (33.3%)</option>
				
				<option value="file12">github.com/VladislavYak/redditclone/pkg/domain/post/vote.go (0.0%)</option>
				
				<option value="file13">github.com/VladislavYak/redditclone/pkg/domain/user/user.go (100.0%)</option>
				
				<option value="file14">github.com/VladislavYak/redditclone/pkg/handlers/comment.go (0.0%)</option>
				
				<option value="file15">github.com/VladislavYak/redditclone/pkg/handlers/middleware/authorization.go (0.0%)</option>
				
				<option value="file16">github.com/VladislavYak/redditclone/pkg/handlers/posts.go (0.0%)</option>
				
				<option value="file17">github.com/VladislavYak/redditclone/pkg/handlers/user.go (0.0%)</option>
				
				<option value="file18">github.com/VladislavYak/redditclone/pkg/infrastructure/mongodb/client.go (0.0%)</option>
				
				<option value="file19">github.com/VladislavYak/redditclone/pkg/infrastructure/mongodb/comment.go (0.0%)</option>
				
				<option value="file20">github.com/VladislavYak/redditclone/pkg/infrastructure/mongodb/post.go (0.0%)</option>
				
				<option value="file21">github.com/VladislavYak/redditclone/pkg/infrastructure/postgres/auth.go (0.0%)</option>
				
				<option value="file22">github.com/VladislavYak/redditclone/pkg/infrastructure/postgres/pool.go (0.0%)</option>
				
				<option value="file23">github.com/VladislavYak/redditclone/pkg/infrastructure/postgres/user.go (0.0%)</option>
				
				<option value="file24">github.com/VladislavYak/redditclone/pkg/infrastructure/ram/comment.go (0.0%)</option>
				
				<option value="file25">github.com/VladislavYak/redditclone/pkg/infrastructure/ram/post.go (0.0%)</option>
				
				<option value="file26">github.com/VladislavYak/redditclone/pkg/infrastructure/ram/user.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"

        "github.com/VladislavYak/redditclone/pkg/handlers"
        // "github.com/VladislavYak/redditclone/pkg/post"
        "github.com/VladislavYak/redditclone/pkg/application"

        "github.com/VladislavYak/redditclone/pkg/domain/auth"
        customMiddleware "github.com/VladislavYak/redditclone/pkg/handlers/middleware"
        "github.com/VladislavYak/redditclone/pkg/infrastructure/mongodb"
        "github.com/VladislavYak/redditclone/pkg/infrastructure/postgres"
        jwt "github.com/golang-jwt/jwt/v5"
        echojwt "github.com/labstack/echo-jwt/v4"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

// yakovlev: add proper error handling
// yakovlev: add proper logging
// yakovlev: add proper concurrency handling using mutexes
const (
        api = "/api"
)

func main() <span class="cov0" title="0">{
        cfg := mongodb.Config{
                URI:        "mongodb://localhost:27017",
                Database:   "testing",
                TimeoutSec: 2,
        }

        // need to
        var JwtSecret = "secret"

        // better user DI somehow here

        client, _ := mongodb.NewMongoClient(cfg)
        pgPool, _ := postgres.NewPgPool()

        UserRepo := postgres.NewUserRepoPostgres(pgPool)
        // UserRepo := ram.NewUserRepo()
        PostRepo := mongodb.NewPostRepoMongo(client, "testing", "posts")
        // PostRepo := ram.NewPostRepo()
        AuthRepo := postgres.NewAuthRepoPostgres(pgPool)

        CommentRepo := mongodb.NewCommentRepoMongo(client, "testing", "posts")
        // CommentRepo := ram.NewCommentRepo()

        PostImpl := application.NewPostImpl(PostRepo)
        CommentImpl := application.NewCommentImpl(PostRepo, CommentRepo)
        UserImpl := application.NewUserImpl(UserRepo, AuthRepo, JwtSecret)
        AuthImpl := application.NewAuthImpl(AuthRepo)

        postHandler := handlers.PostHandler{Implementation: PostImpl}
        commentHandler := handlers.CommentHandler{Implementation: CommentImpl}

        userHandler := handlers.UserHandler{Impl: UserImpl}
        // loginHandler := handlers.LoginHandler{UserRepo: *UserRepo}

        e := echo.New()

        e.Pre(middleware.RemoveTrailingSlash())
        e.Logger.Debug()

        g := e.Group(api)

        // Отдаем статические файлы
        e.Static("/static", "static")
        // e.Static("/", "static/html") // Отдаем HTML файлы по корневому маршруту
        e.File("/", "static/html/index.html")

        g.POST("/register", userHandler.Register)
        g.POST("/login", userHandler.Login)
        g.GET("/posts", postHandler.GetPosts)
        g.GET("/posts/:CategoryName", postHandler.GetPostsByCategoryName)
        g.GET("/post/:id", postHandler.GetPostByID)

        g.GET("/user/:username", postHandler.GetPostByUsername)

        </span><span class="cov0" title="0">{
                config := echojwt.Config{
                        NewClaimsFunc: func(c echo.Context) jwt.Claims </span><span class="cov0" title="0">{
                                return new(auth.JwtCustomClaims)
                        }</span>,
                        SigningKey: []byte("secret"),
                }

                <span class="cov0" title="0">fmt.Println("config", config)

                g.Use(customMiddleware.CustomAuth(&amp;config, AuthImpl))
                // в общем кажется, что надо откащываться от этой withConfig и писать свою мидлварь для авторизации где есть проверка на валидность токена в бд
                // basicAuthMiddleware := echojwt.WithConfig(config)

                // где-то тут, наверное, мне нужна мидллаварь, которая ходит в базу и проверяет валидность токена.
                // но еще я делаб одинаковые операции с Claims. Вот их бы тоже унести куда-то.
                // эти операции делать надо после проверки мидлвар.
                // g.Use(basicAuthMiddleware)

                g.POST("/posts", postHandler.PostPost)
                // deletePost особенный - бросать нужно 401, когда пытаемся удалить не свой пост.
                // при этом в идеале фронт даже показывать кнопку delete не должен
                g.DELETE("/post/:id", postHandler.DeletePost)
                g.POST("/post/:id", commentHandler.AddComment)
                g.DELETE("/post/:id/:commentId", commentHandler.DeleteComment)

                g.GET("/post/:id/downvote", postHandler.Downvote)
                g.GET("/post/:id/upvote", postHandler.Upvote)
                g.GET("/post/:id/unvote", postHandler.Unvote)</span>
        }

        <span class="cov0" title="0">e.Logger.Fatal(e.Start(":1323"))</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/domain/auth/auth.go
//
// Generated by this command:
//
//        mockgen -source pkg/domain/auth/auth.go -destination mocks/auth_repository_mock.go -package mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        time "time"

        gomock "go.uber.org/mock/gomock"
)

// MockAuthRepository is a mock of AuthRepository interface.
type MockAuthRepository struct {
        ctrl     *gomock.Controller
        recorder *MockAuthRepositoryMockRecorder
        isgomock struct{}
}

// MockAuthRepositoryMockRecorder is the mock recorder for MockAuthRepository.
type MockAuthRepositoryMockRecorder struct {
        mock *MockAuthRepository
}

// NewMockAuthRepository creates a new mock instance.
func NewMockAuthRepository(ctrl *gomock.Controller) *MockAuthRepository <span class="cov8" title="1">{
        mock := &amp;MockAuthRepository{ctrl: ctrl}
        mock.recorder = &amp;MockAuthRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthRepository) EXPECT() *MockAuthRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddJWT mocks base method.
func (m *MockAuthRepository) AddJWT(ctx context.Context, Token, UserID string, IssuedAt, ExpiresAt time.Time) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddJWT", ctx, Token, UserID, IssuedAt, ExpiresAt)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddJWT indicates an expected call of AddJWT.
func (mr *MockAuthRepositoryMockRecorder) AddJWT(ctx, Token, UserID, IssuedAt, ExpiresAt any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddJWT", reflect.TypeOf((*MockAuthRepository)(nil).AddJWT), ctx, Token, UserID, IssuedAt, ExpiresAt)
}</span>

// ValidateJWT mocks base method.
func (m *MockAuthRepository) ValidateJWT(ctx context.Context, Token string, ExpiresAt time.Time) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ValidateJWT", ctx, Token, ExpiresAt)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ValidateJWT indicates an expected call of ValidateJWT.
func (mr *MockAuthRepositoryMockRecorder) ValidateJWT(ctx, Token, ExpiresAt any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateJWT", reflect.TypeOf((*MockAuthRepository)(nil).ValidateJWT), ctx, Token, ExpiresAt)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/domain/comment/repository.go
//
// Generated by this command:
//
//        mockgen -source pkg/domain/comment/repository.go -destination mocks/comment_repository_mock.go -package mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        comment "github.com/VladislavYak/redditclone/pkg/domain/comment"
        gomock "go.uber.org/mock/gomock"
)

// MockCommentRepository is a mock of CommentRepository interface.
type MockCommentRepository struct {
        ctrl     *gomock.Controller
        recorder *MockCommentRepositoryMockRecorder
        isgomock struct{}
}

// MockCommentRepositoryMockRecorder is the mock recorder for MockCommentRepository.
type MockCommentRepositoryMockRecorder struct {
        mock *MockCommentRepository
}

// NewMockCommentRepository creates a new mock instance.
func NewMockCommentRepository(ctrl *gomock.Controller) *MockCommentRepository <span class="cov8" title="1">{
        mock := &amp;MockCommentRepository{ctrl: ctrl}
        mock.recorder = &amp;MockCommentRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommentRepository) EXPECT() *MockCommentRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddComment mocks base method.
func (m *MockCommentRepository) AddComment(arg0 context.Context, arg1 string, arg2 *comment.Comment) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddComment", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddComment indicates an expected call of AddComment.
func (mr *MockCommentRepositoryMockRecorder) AddComment(arg0, arg1, arg2 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddComment", reflect.TypeOf((*MockCommentRepository)(nil).AddComment), arg0, arg1, arg2)
}</span>

// DeleteComment mocks base method.
func (m *MockCommentRepository) DeleteComment(arg0 context.Context, arg1, arg2 string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteComment", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteComment indicates an expected call of DeleteComment.
func (mr *MockCommentRepositoryMockRecorder) DeleteComment(arg0, arg1, arg2 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteComment", reflect.TypeOf((*MockCommentRepository)(nil).DeleteComment), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/domain/post/repository.go
//
// Generated by this command:
//
//        mockgen -source pkg/domain/post/repository.go -destination mocks/post_repository_mock.go -package mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        post "github.com/VladislavYak/redditclone/pkg/domain/post"
        gomock "go.uber.org/mock/gomock"
)

// MockPostRepository is a mock of PostRepository interface.
type MockPostRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPostRepositoryMockRecorder
        isgomock struct{}
}

// MockPostRepositoryMockRecorder is the mock recorder for MockPostRepository.
type MockPostRepositoryMockRecorder struct {
        mock *MockPostRepository
}

// NewMockPostRepository creates a new mock instance.
func NewMockPostRepository(ctrl *gomock.Controller) *MockPostRepository <span class="cov8" title="1">{
        mock := &amp;MockPostRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPostRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostRepository) EXPECT() *MockPostRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddPost mocks base method.
func (m *MockPostRepository) AddPost(ctx context.Context, Post *post.Post) (*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddPost", ctx, Post)
        ret0, _ := ret[0].(*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddPost indicates an expected call of AddPost.
func (mr *MockPostRepositoryMockRecorder) AddPost(ctx, Post any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPost", reflect.TypeOf((*MockPostRepository)(nil).AddPost), ctx, Post)
}</span>

// DeletePost mocks base method.
func (m *MockPostRepository) DeletePost(ctx context.Context, Id string) (*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeletePost", ctx, Id)
        ret0, _ := ret[0].(*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeletePost indicates an expected call of DeletePost.
func (mr *MockPostRepositoryMockRecorder) DeletePost(ctx, Id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePost", reflect.TypeOf((*MockPostRepository)(nil).DeletePost), ctx, Id)
}</span>

// GetAllPosts mocks base method.
func (m *MockPostRepository) GetAllPosts(ctx context.Context) ([]*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllPosts", ctx)
        ret0, _ := ret[0].([]*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllPosts indicates an expected call of GetAllPosts.
func (mr *MockPostRepositoryMockRecorder) GetAllPosts(ctx any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllPosts", reflect.TypeOf((*MockPostRepository)(nil).GetAllPosts), ctx)
}</span>

// GetPostByID mocks base method.
func (m *MockPostRepository) GetPostByID(ctx context.Context, ID string) (*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPostByID", ctx, ID)
        ret0, _ := ret[0].(*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPostByID indicates an expected call of GetPostByID.
func (mr *MockPostRepositoryMockRecorder) GetPostByID(ctx, ID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPostByID", reflect.TypeOf((*MockPostRepository)(nil).GetPostByID), ctx, ID)
}</span>

// GetPostsByCategoryName mocks base method.
func (m *MockPostRepository) GetPostsByCategoryName(ctx context.Context, CategoryName string) ([]*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPostsByCategoryName", ctx, CategoryName)
        ret0, _ := ret[0].([]*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPostsByCategoryName indicates an expected call of GetPostsByCategoryName.
func (mr *MockPostRepositoryMockRecorder) GetPostsByCategoryName(ctx, CategoryName any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPostsByCategoryName", reflect.TypeOf((*MockPostRepository)(nil).GetPostsByCategoryName), ctx, CategoryName)
}</span>

// GetPostsByUsername mocks base method.
func (m *MockPostRepository) GetPostsByUsername(ctx context.Context, Username string) ([]*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPostsByUsername", ctx, Username)
        ret0, _ := ret[0].([]*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPostsByUsername indicates an expected call of GetPostsByUsername.
func (mr *MockPostRepositoryMockRecorder) GetPostsByUsername(ctx, Username any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPostsByUsername", reflect.TypeOf((*MockPostRepository)(nil).GetPostsByUsername), ctx, Username)
}</span>

// Unvote mocks base method.
func (m *MockPostRepository) Unvote(ctx context.Context, Id string) (*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Unvote", ctx, Id)
        ret0, _ := ret[0].(*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Unvote indicates an expected call of Unvote.
func (mr *MockPostRepositoryMockRecorder) Unvote(ctx, Id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unvote", reflect.TypeOf((*MockPostRepository)(nil).Unvote), ctx, Id)
}</span>

// UpdateScore mocks base method.
func (m *MockPostRepository) UpdateScore(ct context.Context, Id string) (*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateScore", ct, Id)
        ret0, _ := ret[0].(*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateScore indicates an expected call of UpdateScore.
func (mr *MockPostRepositoryMockRecorder) UpdateScore(ct, Id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateScore", reflect.TypeOf((*MockPostRepository)(nil).UpdateScore), ct, Id)
}</span>

// Vote mocks base method.
func (m *MockPostRepository) Vote(ctx context.Context, PostId string, vote int) (*post.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Vote", ctx, PostId, vote)
        ret0, _ := ret[0].(*post.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Vote indicates an expected call of Vote.
func (mr *MockPostRepositoryMockRecorder) Vote(ctx, PostId, vote any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Vote", reflect.TypeOf((*MockPostRepository)(nil).Vote), ctx, PostId, vote)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/domain/user/user.go
//
// Generated by this command:
//
//        mockgen -source pkg/domain/user/user.go -destination mocks/user_repository_mock.go -package mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        user "github.com/VladislavYak/redditclone/pkg/domain/user"
        gomock "go.uber.org/mock/gomock"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
        isgomock struct{}
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov8" title="1">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUserRepository) Create(ctx context.Context, User *user.User, Password string) (*user.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, User, Password)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserRepositoryMockRecorder) Create(ctx, User, Password any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserRepository)(nil).Create), ctx, User, Password)
}</span>

// GetUser mocks base method.
func (m *MockUserRepository) GetUser(ctx context.Context, User *user.User) (*user.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", ctx, User)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockUserRepositoryMockRecorder) GetUser(ctx, User any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockUserRepository)(nil).GetUser), ctx, User)
}</span>

// GetUserPassword mocks base method.
func (m *MockUserRepository) GetUserPassword(ctx context.Context, arg1 *user.User) (string, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserPassword", ctx, arg1)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserPassword indicates an expected call of GetUserPassword.
func (mr *MockUserRepositoryMockRecorder) GetUserPassword(ctx, arg1 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserPassword", reflect.TypeOf((*MockUserRepository)(nil).GetUserPassword), ctx, arg1)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package application

import (
        "context"
        "time"

        "github.com/VladislavYak/redditclone/pkg/domain/auth"
        "github.com/go-faster/errors"
)

type AuthRepo interface {
        ValidateSession(ctx context.Context, Token string, ExpiresAt time.Time)
}

type AuthImpl struct {
        ar auth.AuthRepository
}

func NewAuthImpl(repo auth.AuthRepository) *AuthImpl <span class="cov0" title="0">{
        // yakovlev: JWTSecret which?
        return &amp;AuthImpl{ar: repo}
}</span>

// need to be moved to auth
func (ai *AuthImpl) ValidateSession(ctx context.Context, Token string, ExpiresAt time.Time) error <span class="cov0" title="0">{
        const op = "ValidateSession"
        err := ai.ar.ValidateJWT(ctx, Token, ExpiresAt)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package application

import (
        "context"

        "github.com/VladislavYak/redditclone/pkg/domain/comment"
        commentC "github.com/VladislavYak/redditclone/pkg/domain/comment"
        postP "github.com/VladislavYak/redditclone/pkg/domain/post"
        "github.com/go-faster/errors"
)

type CommentInterface interface {
        AddComment(context.Context, string, *comment.Comment) (*postP.Post, error)
        DeleteComment(context.Context, string, string) (*postP.Post, error)
}

var _ CommentInterface = new(CommentImpl)

type CommentImpl struct {
        PostRepo    postP.PostRepository
        CommentRepo commentC.CommentRepository
}

func NewCommentImpl(repoP postP.PostRepository, repoC commentC.CommentRepository) *CommentImpl <span class="cov0" title="0">{
        return &amp;CommentImpl{PostRepo: repoP, CommentRepo: repoC}
}</span>

func (ci *CommentImpl) AddComment(ctx context.Context, id string, Comment *comment.Comment) (*postP.Post, error) <span class="cov8" title="1">{
        const op = "AddComment"
        err := ci.CommentRepo.AddComment(ctx, id, Comment)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">returnedPost, err := ci.PostRepo.GetPostByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, nil</span>
}

func (ci *CommentImpl) DeleteComment(ctx context.Context, PostId string, CommentId string) (*postP.Post, error) <span class="cov8" title="1">{
        const op = "DeleteComment"
        err := ci.CommentRepo.DeleteComment(ctx, PostId, CommentId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">returnedPost, err := ci.PostRepo.GetPostByID(ctx, PostId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package application

import (
        "context"

        "github.com/VladislavYak/redditclone/pkg/domain/post"
        postP "github.com/VladislavYak/redditclone/pkg/domain/post"
        "github.com/pkg/errors"
)

// https://gitlab.com/slax0rr/go-beer-api/-/blob/master/application/beer.go?ref_type=heads#L25
// тут я вижу, что определ интерфес. Мне не очень понятно. Зачем он нужен

type PostInterface interface {
        Create(context.Context, *postP.Post) (*postP.Post, error)
        Delete(context.Context, string, string) (*postP.Post, error)
        GetAll(context.Context) ([]*postP.Post, error)
        GetByID(context.Context, string) (*postP.Post, error)
        GetPostsByCategoryName(context.Context, string) ([]*postP.Post, error)
        GetPostsByUsername(context.Context, string) ([]*postP.Post, error)
        Upvote(context.Context, string) (*postP.Post, error)
        Downvote(context.Context, string) (*postP.Post, error)
        Unvote(context.Context, string) (*postP.Post, error)
}

type PostImpl struct {
        repo postP.PostRepository
}

func NewPostImpl(repo postP.PostRepository) *PostImpl <span class="cov0" title="0">{
        return &amp;PostImpl{repo: repo}
}</span>

// Compile-time check if PostImpl implements PostInterface
var _ PostInterface = new(PostImpl)

func (p *PostImpl) Create(ctx context.Context, Post *postP.Post) (*postP.Post, error) <span class="cov8" title="1">{
        const op = "Create"

        returnedPost, err := p.repo.AddPost(ctx, Post)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">returnedPost, err = p.repo.Vote(ctx, returnedPost.Id, 1)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">returnedPost, err = p.repo.UpdateScore(ctx, returnedPost.Id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>
}

func (p *PostImpl) Delete(ctx context.Context, id string, userId string) (*postP.Post, error) <span class="cov8" title="1">{
        const op = "Delete"

        ppost, err := p.repo.GetPostByID(ctx, id)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">if ppost.Author.UserID != userId </span><span class="cov8" title="1">{
                return nil, post.DifferentPostOwnerError
        }</span>

        <span class="cov8" title="1">returnedPost, err := p.repo.DeletePost(ctx, id)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>

}

// yakovlev: тту по идее поитенр не нужен, но его и из интерфейса надо выпилить бы (?)
func (p *PostImpl) GetAll(ctx context.Context) ([]*postP.Post, error) <span class="cov8" title="1">{
        const op = "GetAll"

        returnedPost, err := p.repo.GetAllPosts(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>

}

func (p *PostImpl) GetByID(ctx context.Context, s string) (*postP.Post, error) <span class="cov8" title="1">{
        const op = "GetByID"

        returnedPost, err := p.repo.GetPostByID(ctx, s)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>

}

// yakovlev: тту по идее поитенр не нужен, но его и из интерфейса надо выпилить бы
func (p *PostImpl) GetPostsByCategoryName(ctx context.Context, s string) ([]*postP.Post, error) <span class="cov8" title="1">{
        const op = "GetPostsByCategoryName"

        returnedPost, err := p.repo.GetPostsByCategoryName(ctx, s)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>

}

func (p *PostImpl) GetPostsByUsername(ctx context.Context, s string) ([]*postP.Post, error) <span class="cov8" title="1">{
        const op = "GetPostsByUsername"
        returnedPost, err := p.repo.GetPostsByUsername(ctx, s)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>
}

func (p *PostImpl) Upvote(ctx context.Context, PostId string) (*postP.Post, error) <span class="cov8" title="1">{
        const (
                op       = "Upvote"
                voteSign = 1
        )

        returnedPost, err := p.repo.Vote(ctx, PostId, voteSign)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">returnedPost, err = p.repo.UpdateScore(ctx, PostId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>
}

func (p *PostImpl) Downvote(ctx context.Context, PostId string) (*postP.Post, error) <span class="cov8" title="1">{
        const (
                op       = "Downvote"
                voteSign = -1
        )

        returnedPost, err := p.repo.Vote(ctx, PostId, voteSign)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">returnedPost, err = p.repo.UpdateScore(ctx, PostId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>
}

// fix updatescore
func (p *PostImpl) Unvote(ctx context.Context, PostId string) (*postP.Post, error) <span class="cov8" title="1">{
        const op = "Unvote"
        returnedPost, err := p.repo.Unvote(ctx, PostId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">returnedPost, err = p.repo.UpdateScore(ctx, PostId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return returnedPost, err</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package application

import (
        "context"
        "time"

        "github.com/go-faster/errors"

        "github.com/VladislavYak/redditclone/pkg/domain/auth"
        "github.com/VladislavYak/redditclone/pkg/domain/user"
        jwt "github.com/golang-jwt/jwt/v5"
)

type LoginForm struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type RegisterForm struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type UserInterface interface {
        Login(ctx context.Context, Login, Password string) (string, error)
        Register(ctx context.Context, Login, Password string) (string, error)
}

var _ UserInterface = new(UserImpl)

type UserImpl struct {
        ur user.UserRepository
        ar auth.AuthRepository
        // lazy now
        JWTSecret string
}

func NewUserImpl(repo user.UserRepository, AuthRepo auth.AuthRepository, JwtSecret string) *UserImpl <span class="cov0" title="0">{
        // yakovlev: JWTSecret which?
        return &amp;UserImpl{ur: repo, ar: AuthRepo, JWTSecret: JwtSecret}
}</span>

func (ui *UserImpl) Register(ctx context.Context, Login, Password string) (string, error) <span class="cov8" title="1">{
        const op = "Register"

        u := user.NewUser(Login)

        if _, err := ui.ur.GetUser(ctx, u); !errors.Is(err, user.UserNotExistsError) </span><span class="cov8" title="1">{
                return "", user.UserAlreadyExistsError
        }</span>

        <span class="cov8" title="1">u, err := ui.ur.Create(ctx, u, Password)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">issuedAt := time.Now()
        expiresAt := issuedAt.Add(15 * time.Minute) // Shortened lifetime for security

        // Генерируем JWT
        Claims := &amp;auth.JwtCustomClaims{
                Login:  Login,
                UserID: u.UserID,
                RegisteredClaims: jwt.RegisteredClaims{
                        IssuedAt:  jwt.NewNumericDate(issuedAt),
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                },
        }
        Token, err := auth.GenerateJWTToken(Claims, ui.JWTSecret)

        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">if err = ui.ar.AddJWT(ctx, Token, Claims.UserID, Claims.IssuedAt.Time, Claims.ExpiresAt.Time); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">return Token, nil</span>
}

func (ui *UserImpl) Login(ctx context.Context, Login, Password string) (string, error) <span class="cov8" title="1">{
        const op = "Login"

        User, err := ui.ur.GetUser(ctx, user.NewUser(Login))
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">actualPass, err := ui.ur.GetUserPassword(ctx, User)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, op)
        }</span>

        <span class="cov8" title="1">if actualPass != Password </span><span class="cov8" title="1">{
                return "", auth.InvalidPasswordError
        }</span>

        <span class="cov0" title="0">claims := &amp;auth.JwtCustomClaims{
                Login:  Login,
                UserID: User.UserID,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * 72)),
                },
        }

        token, err := auth.GenerateJWTToken(claims, ui.JWTSecret)

        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">return token, nil</span>

}
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth

import (
        "github.com/golang-jwt/jwt/v5"
)

func GenerateJWTToken(Claims *JwtCustomClaims, Secret string) (string, error) <span class="cov8" title="1">{

        Token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims)

        SignedToken, err := Token.SignedString([]byte(Secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", InvalidTokenError
        }</span>
        <span class="cov8" title="1">return SignedToken, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package comment

import (
        "time"

        "github.com/VladislavYak/redditclone/pkg/domain/user"
)

type Comment struct {
        Created time.Time `json:"created"`
        Author  user.User `json:"author"`
        Body    string    `json:"body"`
        Id      string    `json:"id"`
}

func NewComment(Author user.User, Body string) *Comment <span class="cov0" title="0">{
        return &amp;Comment{Created: time.Now().UTC(), Author: Author, Body: Body}
}</span>

func (c *Comment) WithId(id string) *Comment <span class="cov0" title="0">{
        c.Id = id
        return c
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package post

import (
        "time"

        "github.com/VladislavYak/redditclone/pkg/domain/comment"
        "github.com/VladislavYak/redditclone/pkg/domain/user"
)

// need adding more fields
type Post struct {
        Id               string            `json:"id"`
        Category         string            `json:"category"`
        Type             string            `json:"type"`
        Url              string            `json:"url,omitempty"`
        Text             string            `json:"text,omitempty"`
        Title            string            `json:"title"`
        Votes            []Vote            `json:"votes"`
        Comments         []comment.Comment `json:"comments"`
        Created          time.Time         `json:"created"`
        UpvotePercentage int               `json:"upvotePercentage"`

        Score int `json:"score"`
        Views int `json:"views"`

        Author user.User `json:"author"`
}

func NewPost(category string, postType string, url string, text string, title string, author user.User) *Post <span class="cov8" title="1">{
        return &amp;Post{
                Category: category,
                Type:     postType,
                Url:      url,
                Text:     text,
                Title:    title,
                Author:   author,
                Created:  time.Now().UTC(),
                Score:    0,
                Views:    0,
                Comments: []comment.Comment{},
                Votes:    []Vote{},
        }
}</span>

func (p *Post) WithId(id string) *Post <span class="cov0" title="0">{
        p.Id = id
        return p
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package post

type Vote struct {
        User      string `json:"user"`
        VoteScore int    `json:"vote" bson:"vote"`
}

func (v *Vote) WithVote(value int) *Vote <span class="cov0" title="0">{
        v.VoteScore = value

        return v
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package user

type User struct {
        Username string `json:"username"`
        // Password string
        UserID string `json:"id"`
}

func NewUser(Username string) *User <span class="cov8" title="1">{
        return &amp;User{Username: Username}
}</span>

// yakovlev: это надо бы убрать
func (u *User) WithID(Id string) *User <span class="cov8" title="1">{
        u.UserID = Id
        return u
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "context"
        "fmt"
        "net/http"

        "github.com/VladislavYak/redditclone/pkg/application"
        "github.com/VladislavYak/redditclone/pkg/domain/auth"
        "github.com/VladislavYak/redditclone/pkg/domain/comment"
        "github.com/VladislavYak/redditclone/pkg/domain/user"
        jwt "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

type CommentHandler struct {
        Implementation application.CommentInterface
}

func (ch *CommentHandler) AddComment(c echo.Context) error <span class="cov0" title="0">{
        us := c.Get("user").(*jwt.Token)
        claims := us.Claims.(*auth.JwtCustomClaims)

        id := c.Param("id")

        fmt.Println("im inside addComment handler")
        fmt.Println("id", id)

        var body struct {
                Comment string `json:"comment"`
        }

        fmt.Println("body", body)

        if err := c.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return c.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">Comment := comment.NewComment(*user.NewUser(claims.Login).WithID(claims.UserID), body.Comment)

        returnedPost, err := ch.Implementation.AddComment(context.TODO(), id, Comment)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusCreated, returnedPost)</span>
}

func (ch *CommentHandler) DeleteComment(c echo.Context) error <span class="cov0" title="0">{
        id := c.Param("id")
        CommentId := c.Param("commentId")

        returnedPost, err := ch.Implementation.DeleteComment(context.TODO(), id, CommentId)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>
        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusCreated, returnedPost)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "errors"
        "fmt"

        "github.com/VladislavYak/redditclone/pkg/application"
        "github.com/VladislavYak/redditclone/pkg/domain/auth"
        "github.com/golang-jwt/jwt/v5"
        echojwt "github.com/labstack/echo-jwt/v4"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

// yakovlev: prettify it, it looks awful right now
func CustomAuth(config *echojwt.Config, authService *application.AuthImpl) echo.MiddlewareFunc <span class="cov0" title="0">{

        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{

                        if config.Skipper == nil </span><span class="cov0" title="0">{
                                config.Skipper = middleware.DefaultSkipper
                        }</span>
                        <span class="cov0" title="0">if config.ContextKey == "" </span><span class="cov0" title="0">{
                                config.ContextKey = "user"
                        }</span>
                        <span class="cov0" title="0">if config.TokenLookup == "" &amp;&amp; len(config.TokenLookupFuncs) == 0 </span><span class="cov0" title="0">{
                                config.TokenLookup = "header:Authorization:Bearer "
                        }</span>
                        <span class="cov0" title="0">if config.SigningMethod == "" </span><span class="cov0" title="0">{
                                config.SigningMethod = echojwt.AlgorithmHS256
                        }</span>

                        <span class="cov0" title="0">if config.NewClaimsFunc == nil </span><span class="cov0" title="0">{
                                config.NewClaimsFunc = func(c echo.Context) jwt.Claims </span><span class="cov0" title="0">{
                                        return jwt.MapClaims{}
                                }</span>
                        }
                        <span class="cov0" title="0">if config.SigningKey == nil &amp;&amp; len(config.SigningKeys) == 0 &amp;&amp; config.KeyFunc == nil &amp;&amp; config.ParseTokenFunc == nil </span><span class="cov0" title="0">{
                                return errors.New("jwt middleware requires signing key")
                        }</span>
                        // if config.KeyFunc == nil {
                        //         config.KeyFunc = config.defaultKeyFunc
                        // }
                        // if config.ParseTokenFunc == nil {
                        //         config.ParseTokenFunc = echojwt.defaultParseTokenFunc
                        // }

                        // if len(config.TokenLookupFuncs) &gt; 0 {
                        //         extractors = append(config.TokenLookupFuncs, extractors...)
                        // }

                        <span class="cov0" title="0">fmt.Println("im inside custom auth")

                        fmt.Println("config.TokenLookup", config.TokenLookup)

                        extractors, ceErr := echojwt.CreateExtractors(config.TokenLookup)

                        fmt.Println("extracted extractor")

                        if ceErr != nil </span><span class="cov0" title="0">{
                                fmt.Println("ceErr CreateExtractors", ceErr)
                                return ceErr
                        }</span>
                        // var lastExtractorErr error
                        // var lastTokenErr error

                        <span class="cov0" title="0">fmt.Println("len(extractors)", len(extractors))

                        for _, extractor := range extractors </span><span class="cov0" title="0">{
                                auths, extrErr := extractor(c)
                                fmt.Println("len(auths)", len(auths))
                                fmt.Println("extrErr", extrErr)
                                if extrErr != nil </span><span class="cov0" title="0">{
                                        // lastExtractorErr = extrErr
                                        continue</span>
                                }
                                <span class="cov0" title="0">for _, tokenString := range auths </span><span class="cov0" title="0">{
                                        fmt.Println("tokenString", tokenString)

                                        hashSecretGetter := func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                                                // method, ok := token.Method.(*jwt.SigningMethodHMAC)
                                                // if !ok || method.Alg() != "HS256" {
                                                //         return nil, fmt.Errorf("bad sign method")
                                                // }
                                                return []byte("secret"), nil
                                        }</span>

                                        // token, err := jwt.Parse(tokenString, hashSecretGetter)

                                        <span class="cov0" title="0">claims := auth.JwtCustomClaims{}
                                        token, err := jwt.ParseWithClaims(tokenString, &amp;claims, hashSecretGetter)

                                        fmt.Println("token (after Parse)", token)
                                        fmt.Println("err (after Parse)", err)
                                        if err != nil || !token.Valid </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">fmt.Println("before running ValidateSession")
                                        err = authService.ValidateSession(c.Request().Context(), token.Raw, claims.ExpiresAt.Time)
                                        if err != nil </span><span class="cov0" title="0">{
                                                // yakovlev: пока что хз как тут ошибки обарабывать, errors.Wrap или ХТТПШные?
                                                return err
                                        }</span>

                                        // Store user information from token into context.
                                        <span class="cov0" title="0">c.Set(config.ContextKey, token)
                                        if config.SuccessHandler != nil </span><span class="cov0" title="0">{
                                                config.SuccessHandler(c)
                                        }</span>
                                        <span class="cov0" title="0">return next(c)</span>
                                }
                        }

                        <span class="cov0" title="0">return nil</span>

                }
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "context"
        "errors"
        "net/http"

        "github.com/VladislavYak/redditclone/pkg/application"
        "github.com/VladislavYak/redditclone/pkg/domain/auth"
        "github.com/VladislavYak/redditclone/pkg/domain/post"
        "github.com/VladislavYak/redditclone/pkg/domain/user"
        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

type PostParams struct {
        Category string `json:"category"`
        Type     string `json:"type"`
        Url      string `json:"url,omitempty"`
        Text     string `json:"text,omitempty"`
        Title    string `json:"title"`
}

type PostHandler struct {
        Implementation application.PostInterface
}

func (ph *PostHandler) GetPosts(c echo.Context) error <span class="cov0" title="0">{
        posts, err := ph.Implementation.GetAll(context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, posts)</span>
}

func (ph *PostHandler) GetPostsByCategoryName(c echo.Context) error <span class="cov0" title="0">{

        CategoryName := c.Param("CategoryName")

        posts, err := ph.Implementation.GetPostsByCategoryName(context.TODO(), CategoryName)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, posts)</span>
}

func (ph *PostHandler) GetPostByID(c echo.Context) error <span class="cov0" title="0">{
        id := c.Param("id")

        post, err := ph.Implementation.GetByID(context.TODO(), id)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, post)</span>

}

func (ph *PostHandler) GetPostByUsername(c echo.Context) error <span class="cov0" title="0">{
        username := c.Param("username")

        post, err := ph.Implementation.GetPostsByUsername(context.TODO(), username)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, post)</span>

}

func (ph *PostHandler) PostPost(c echo.Context) error <span class="cov0" title="0">{

        us := c.Get("user").(*jwt.Token)

        claims := us.Claims.(*auth.JwtCustomClaims)

        ctx := c.Request().Context()
        ctx = context.WithValue(ctx, "Username", claims.Login)
        ctx = context.WithValue(ctx, "UserID", claims.UserID)

        pp := &amp;PostParams{}
        if err := c.Bind(pp); err != nil </span><span class="cov0" title="0">{
                c.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">Post := post.NewPost(pp.Category, pp.Type, pp.Url, pp.Text, pp.Title, *user.NewUser(claims.Login).WithID(claims.UserID))

        postReturned, err := ph.Implementation.Create(ctx, Post)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusCreated, postReturned)</span>
}

func (ph *PostHandler) DeletePost(c echo.Context) error <span class="cov0" title="0">{

        id := c.Param("id")

        us := c.Get("user").(*jwt.Token)

        claims := us.Claims.(*auth.JwtCustomClaims)

        ctx := c.Request().Context()
        ctx = context.WithValue(ctx, "Username", claims.Login)
        ctx = context.WithValue(ctx, "UserID", claims.UserID)

        deletedPost, err := ph.Implementation.Delete(ctx, id, claims.UserID)

        if errors.Is(err, post.DifferentPostOwnerError) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusForbidden, err)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, deletedPost)</span>
}

func (ph *PostHandler) Upvote(c echo.Context) error <span class="cov0" title="0">{
        PostId := c.Param("id")

        us := c.Get("user").(*jwt.Token)
        claims := us.Claims.(*auth.JwtCustomClaims)

        ctx := c.Request().Context()
        ctx = context.WithValue(ctx, "Username", claims.Login)
        ctx = context.WithValue(ctx, "UserID", claims.UserID)

        returnedPost, err := ph.Implementation.Upvote(ctx, PostId)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusOK, returnedPost)</span>

}

func (ph *PostHandler) Downvote(c echo.Context) error <span class="cov0" title="0">{
        PostId := c.Param("id")

        us := c.Get("user").(*jwt.Token)
        claims := us.Claims.(*auth.JwtCustomClaims)

        ctx := c.Request().Context()
        ctx = context.WithValue(ctx, "Username", claims.Login)
        ctx = context.WithValue(ctx, "UserID", claims.UserID)

        returnedPost, err := ph.Implementation.Downvote(ctx, PostId)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusOK, returnedPost)</span>
}

func (ph *PostHandler) Unvote(c echo.Context) error <span class="cov0" title="0">{
        PostId := c.Param("id")

        us := c.Get("user").(*jwt.Token)
        claims := us.Claims.(*auth.JwtCustomClaims)

        ctx := c.Request().Context()
        ctx = context.WithValue(ctx, "Username", claims.Login)
        ctx = context.WithValue(ctx, "UserID", claims.UserID)

        returnedPost, err := ph.Implementation.Unvote(ctx, PostId)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusOK, returnedPost)</span>

}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "fmt"
        "net/http"

        "github.com/VladislavYak/redditclone/pkg/application"
        "github.com/labstack/echo/v4"
)

type LoginForm struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type RegisterForm struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type UserHandler struct {
        Impl application.UserInterface
}

func (uh *UserHandler) Login(c echo.Context) error <span class="cov0" title="0">{
        form := &amp;LoginForm{}

        if err := c.Bind(form); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">token, err := uh.Impl.Login(c.Request().Context(), form.Username, form.Password)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]string{
                "token": token,
        })</span>
}

func (uh *UserHandler) Register(c echo.Context) error <span class="cov0" title="0">{

        form := &amp;RegisterForm{}

        fmt.Println("before logging")

        if err := c.Bind(form); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">fmt.Println("form.Username", form.Username)
        token, err := uh.Impl.Register(c.Request().Context(), form.Username, form.Password)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("i was here")
                return echo.NewHTTPError(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">fmt.Println("token Register", token)

        return c.JSON(http.StatusOK, map[string]string{
                "token": token,
        })</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package mongodb

import (
        "context"
        "time"

        "go.mongodb.org/mongo-driver/v2/mongo"
        "go.mongodb.org/mongo-driver/v2/mongo/options"
)

// Config хранит конфигурацию для подключения к MongoDB.
type Config struct {
        URI        string
        Database   string
        TimeoutSec int
}

// NewMongoClient создает и возвращает новый mongo.Client.
func NewMongoClient(cfg Config) (*mongo.Client, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(cfg.TimeoutSec)*time.Second)
        defer cancel()

        client, err := mongo.Connect(options.Client().ApplyURI(cfg.URI))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Проверяем подключение
        <span class="cov0" title="0">err = client.Ping(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package mongodb

import (
        "context"
        "fmt"

        "github.com/VladislavYak/redditclone/pkg/domain"
        "github.com/VladislavYak/redditclone/pkg/domain/comment"
        "github.com/go-faster/errors"
        "go.mongodb.org/mongo-driver/v2/bson"
        "go.mongodb.org/mongo-driver/v2/mongo"
)

var _ comment.CommentRepository = new(CommentRepoMongo)

type CommentRepoMongo struct {
        Collection *mongo.Collection
}

func NewCommentRepoMongo(client *mongo.Client, dbName string, collectionName string) *CommentRepoMongo <span class="cov0" title="0">{

        collection := client.Database(dbName).Collection(collectionName)

        return &amp;CommentRepoMongo{
                Collection: collection,
        }
}</span>

func (cr *CommentRepoMongo) AddComment(ctx context.Context, Id string, Comment *comment.Comment) error <span class="cov0" title="0">{
        const op = "Add Comment"
        fmt.Println("inserteing comment")

        Comment.WithId(bson.NewObjectID().Hex())

        objID, err := bson.ObjectIDFromHex(Id)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">update := bson.M{
                "$push": bson.M{
                        "comments": Comment,
                },
        }

        result, err := cr.Collection.UpdateOne(
                context.TODO(),
                bson.M{"_id": objID},
                update,
        )
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return domain.PostNotFoundError
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (cr *CommentRepoMongo) DeleteComment(ctx context.Context, Id string, CommentId string) error <span class="cov0" title="0">{

        objID, err := bson.ObjectIDFromHex(Id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid post ID: %w", err)
        }</span>

        // Define the update operation using $pull
        <span class="cov0" title="0">update := bson.M{
                "$pull": bson.M{
                        "comments": bson.M{
                                "id": CommentId,
                        },
                },
        }

        // Update the post in MongoDB
        result, err := cr.Collection.UpdateOne(
                context.TODO(),
                bson.M{"_id": objID},
                update,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete comment: %w", err)
        }</span>
        <span class="cov0" title="0">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return domain.PostNotFoundError
        }</span>
        <span class="cov0" title="0">if result.ModifiedCount == 0 </span><span class="cov0" title="0">{
                return comment.CommentNotFoundError
        }</span>

        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file20" style="display: none">package mongodb

import (
        "context"
        "fmt"
        "time"

        "github.com/VladislavYak/redditclone/pkg/domain"
        "github.com/VladislavYak/redditclone/pkg/domain/comment"
        "github.com/VladislavYak/redditclone/pkg/domain/post"
        "github.com/VladislavYak/redditclone/pkg/domain/user"
        "github.com/go-faster/errors"
        "go.mongodb.org/mongo-driver/v2/bson"
        "go.mongodb.org/mongo-driver/v2/mongo"
        "go.mongodb.org/mongo-driver/v2/mongo/options"
)

var _ post.PostRepository = new(PostRepoMongo)

type PostRepoMongo struct {
        Collection *mongo.Collection
        Client     *mongo.Client
}

func NewPostRepoMongo(client *mongo.Client, dbName, collectionName string) *PostRepoMongo <span class="cov0" title="0">{

        collection := client.Database(dbName).Collection(collectionName)

        return &amp;PostRepoMongo{
                Collection: collection,
                Client:     client,
        }
}</span>

type postTmp struct {
        ObjectID         bson.ObjectID     `bson:"_id,omitempty"`
        Category         string            `json:"category"`
        Type             string            `json:"type"`
        Url              string            `json:"url,omitempty"`
        Text             string            `json:"text,omitempty"`
        Title            string            `json:"title"`
        Votes            []post.Vote       `json:"votes"`
        Comments         []comment.Comment `json:"comments"`
        Created          time.Time         `json:"created"`
        UpvotePercentage int               `json:"upvotePercentage"`
        Score            int               `json:"score"`
        Views            int               `json:"views"`
        Author           user.User         `json:"author"`
}

func (pt *postTmp) ToPost() *post.Post <span class="cov0" title="0">{
        return &amp;post.Post{
                Id:               pt.ObjectID.Hex(),
                Category:         pt.Category,
                Type:             pt.Type,
                Url:              pt.Url,
                Text:             pt.Text,
                Title:            pt.Title,
                Votes:            pt.Votes,
                Comments:         pt.Comments,
                Created:          pt.Created,
                UpvotePercentage: pt.UpvotePercentage,
                Score:            pt.Score,
                Views:            pt.Views,
                Author:           pt.Author,
        }
}</span>

func (pp *PostRepoMongo) GetAllPosts(ctx context.Context) ([]*post.Post, error) <span class="cov0" title="0">{
        const op = "GetAllPosts"
        fmt.Println("inside GetAllPosts")
        cursor, err := pp.Collection.Find(context.TODO(), bson.D{})

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">var postsTmp []*postTmp

        if err = cursor.All(context.TODO(), &amp;postsTmp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">var Posts []*post.Post
        for _, postIter := range postsTmp </span><span class="cov0" title="0">{

                Posts = append(Posts, postIter.ToPost())

        }</span>

        <span class="cov0" title="0">return Posts, nil</span>
}

func (pp *PostRepoMongo) GetPostsByCategoryName(ctx context.Context, CategoryName string) ([]*post.Post, error) <span class="cov0" title="0">{
        const op = "GetPostsByCategoryName"
        cursor, err := pp.Collection.Find(context.TODO(), bson.D{{Key: "category", Value: CategoryName}})

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">var postsTmp []*postTmp
        if err = cursor.All(context.TODO(), &amp;postsTmp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">var Posts []*post.Post
        for _, postIter := range postsTmp </span><span class="cov0" title="0">{

                Posts = append(Posts, postIter.ToPost())

        }</span>
        <span class="cov0" title="0">return Posts, nil</span>
}

func (pp *PostRepoMongo) GetPostByID(ctx context.Context, ID string) (*post.Post, error) <span class="cov0" title="0">{
        const op = "GetPostByID"
        value, _ := bson.ObjectIDFromHex(ID)

        fmt.Println("GetPostByID, value", value)

        filter := bson.M{"_id": value}

        var postTmp *postTmp
        err := pp.Collection.FindOne(context.TODO(), filter).Decode(&amp;postTmp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Updated Post:\n%+v\n", postTmp)

        Post := postTmp.ToPost()

        fmt.Println("Post GetPostByID", Post)

        return Post, nil</span>
}

func (pp *PostRepoMongo) GetPostsByUsername(ctx context.Context, Username string) ([]*post.Post, error) <span class="cov0" title="0">{
        cursor, err := pp.Collection.Find(context.TODO(), bson.M{"author.username": Username})

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var postsTmp []*postTmp
        if err = cursor.All(context.TODO(), &amp;postsTmp); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var Posts []*post.Post
        for _, postIter := range postsTmp </span><span class="cov0" title="0">{

                Posts = append(Posts, postIter.ToPost())

        }</span>

        <span class="cov0" title="0">return Posts, nil</span>
}

func (pp *PostRepoMongo) AddPost(ctx context.Context, Post *post.Post) (*post.Post, error) <span class="cov0" title="0">{
        const op = "AddPost"

        // prettify it somehow
        p := &amp;postTmp{
                // Id:               pt.ObjectID.Hex(),
                Category:         Post.Category,
                Type:             Post.Type,
                Url:              Post.Url,
                Text:             Post.Text,
                Title:            Post.Title,
                Votes:            Post.Votes,
                Comments:         Post.Comments,
                Created:          Post.Created,
                UpvotePercentage: Post.UpvotePercentage,
                Score:            Post.Score,
                Views:            Post.Views,
                Author:           Post.Author,
        }

        result, err := pp.Collection.InsertOne(context.TODO(), p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">ReturnedPost := p.ToPost()

        if objID, ok := result.InsertedID.(bson.ObjectID); ok </span><span class="cov0" title="0">{
                // Преобразуем ObjectID в строку (hex-формат)
                IdConverted := objID.Hex()
                ReturnedPost.Id = IdConverted
        }</span> else<span class="cov0" title="0"> {
                return nil, errors.New("cannot convert id")
        }</span>

        <span class="cov0" title="0">fmt.Println("ReturnedPost (AddPost)", ReturnedPost.Id)

        // yakovlev: logging?
        fmt.Println("inserted id", result.InsertedID)
        return ReturnedPost, nil</span>
}

func (pp *PostRepoMongo) DeletePost(ctx context.Context, Id string) (*post.Post, error) <span class="cov0" title="0">{
        const op = "DeletePost"

        value, err := bson.ObjectIDFromHex(Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">_, err = pp.Collection.DeleteOne(context.TODO(), bson.D{{"_id", value}})
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        // yakovlev: check this out
        <span class="cov0" title="0">return nil, nil</span>

        // return nil, errors.New("this id doesnot exist")

}

// func (pp *PostRepoMongo) Upvote(ctx context.Context, PostID string) (*post.Post, error) {
//         const op = "Upvote"
//         userID, ok := ctx.Value("UserID").(string)
//         if !ok {
//                 return nil, errors.New("cannot cast userID to string")
//         }
//         // Convert postID to ObjectID
//         objID, err := bson.ObjectIDFromHex(PostID)
//         if err != nil {
//                 return nil, errors.Wrap(err, op)
//         }
//         filter := bson.M{
//                 "_id": objID,
//         }

//         // Aggregation pipeline для обновления votes
//         update := bson.A{
//                 bson.M{
//                         "$set": bson.M{
//                                 "votes": bson.M{
//                                         "$cond": bson.M{
//                                                 "if": bson.M{
//                                                         "$in": []interface{}{userID, "$votes.user"},
//                                                 },
//                                                 "then": bson.M{
//                                                         "$map": bson.M{
//                                                                 "input": "$votes",
//                                                                 "as":    "vote",
//                                                                 "in": bson.M{
//                                                                         "$cond": bson.M{
//                                                                                 "if": bson.M{"$eq": []interface{}{"$$vote.user", userID}},
//                                                                                 "then": bson.M{
//                                                                                         "user": "$$vote.user",
//                                                                                         "vote": 1,
//                                                                                 },
//                                                                                 "else": "$$vote",
//                                                                         },
//                                                                 },
//                                                         },
//                                                 },
//                                                 "else": bson.M{
//                                                         "$concatArrays": []interface{}{
//                                                                 "$votes",
//                                                                 []bson.M{{
//                                                                         "user": userID,
//                                                                         "vote": 1,
//                                                                 }},
//                                                         },
//                                                 },
//                                         },
//                                 },
//                         },
//                 },
//         }

//         // Опции для возврата обновлённого документа
//         opts := options.FindOneAndUpdate().SetReturnDocument(options.After)

//         // Выполнение атомарного обновления
//         var tmpPost postTmp
//         err = pp.Collection.FindOneAndUpdate(ctx, filter, update, opts).Decode(&amp;tmpPost)

//         ReturnedPost := tmpPost.ToPost()

//         if err == mongo.ErrNoDocuments {
//                 return nil, domain.PostNotFoundError
//         }
//         if err != nil {
//                 return nil, errors.Wrap(err, op)
//         }

//         return ReturnedPost, nil
// }

// // yakovlev: this is almost full copy of Upvote, but lazy now
// func (pp *PostRepoMongo) Downvote(ctx context.Context, PostID string) (*post.Post, error) {
//         const op = "Downvote"
//         userID, ok := ctx.Value("UserID").(string)
//         if !ok {
//                 return nil, errors.New("cannot cast userID to string")
//         }

//         // Convert postID to ObjectID
//         objID, err := bson.ObjectIDFromHex(PostID)
//         if err != nil {
//                 return nil, errors.Wrap(err, op)
//         }
//         filter := bson.M{
//                 "_id": objID,
//         }

//         // Aggregation pipeline для обновления votes
//         update := bson.A{
//                 bson.M{
//                         "$set": bson.M{
//                                 "votes": bson.M{
//                                         "$cond": bson.M{
//                                                 "if": bson.M{
//                                                         "$in": []interface{}{userID, "$votes.user"},
//                                                 },
//                                                 "then": bson.M{
//                                                         "$map": bson.M{
//                                                                 "input": "$votes",
//                                                                 "as":    "vote",
//                                                                 "in": bson.M{
//                                                                         "$cond": bson.M{
//                                                                                 "if": bson.M{"$eq": []interface{}{"$$vote.user", userID}},
//                                                                                 "then": bson.M{
//                                                                                         "user": "$$vote.user",
//                                                                                         "vote": -1,
//                                                                                 },
//                                                                                 "else": "$$vote",
//                                                                         },
//                                                                 },
//                                                         },
//                                                 },
//                                                 "else": bson.M{
//                                                         "$concatArrays": []interface{}{
//                                                                 "$votes",
//                                                                 []bson.M{{
//                                                                         "user": userID,
//                                                                         "vote": 1,
//                                                                 }},
//                                                         },
//                                                 },
//                                         },
//                                 },
//                         },
//                 },
//         }

//         // Опции для возврата обновлённого документа
//         opts := options.FindOneAndUpdate().SetReturnDocument(options.After)

//         // Выполнение атомарного обновления
//         var tmpPost postTmp
//         err = pp.Collection.FindOneAndUpdate(ctx, filter, update, opts).Decode(&amp;tmpPost)

//         if err == mongo.ErrNoDocuments {
//                 return nil, fmt.Errorf("post with ID %s not found", PostID)
//         }
//         if err != nil {
//                 return nil, errors.Wrap(err, op)
//         }

//         ReturnedPost := tmpPost.ToPost()

//         return ReturnedPost, nil

// }

func (pp *PostRepoMongo) Vote(ctx context.Context, PostID string, vote int) (*post.Post, error) <span class="cov0" title="0">{
        const op = "Vote"
        if vote != 1 &amp;&amp; vote != -1 </span><span class="cov0" title="0">{
                return nil, errors.New("vote must be 1 (upvote) or -1 (downvote)")
        }</span>

        <span class="cov0" title="0">userID, ok := ctx.Value("UserID").(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("cannot cast userID to string")
        }</span>

        // Convert postID to ObjectID
        <span class="cov0" title="0">objID, err := bson.ObjectIDFromHex(PostID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objID}

        // Универсальный pipeline
        update := bson.A{
                bson.M{
                        "$set": bson.M{
                                "votes": bson.M{
                                        "$cond": bson.M{
                                                "if": bson.M{
                                                        "$in": []interface{}{userID, "$votes.user"},
                                                },
                                                "then": bson.M{
                                                        "$map": bson.M{
                                                                "input": "$votes",
                                                                "as":    "v",
                                                                "in": bson.M{
                                                                        "$cond": bson.M{
                                                                                "if":   bson.M{"$eq": []interface{}{"$$v.user", userID}},
                                                                                "then": bson.M{"user": "$$v.user", "vote": vote}, // ← вот и всё!
                                                                                "else": "$$v",
                                                                        },
                                                                },
                                                        },
                                                },
                                                "else": bson.M{
                                                        "$concatArrays": []interface{}{
                                                                "$votes",
                                                                []bson.M{{"user": userID, "vote": vote}},
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        opts := options.FindOneAndUpdate().SetReturnDocument(options.After)

        var tmpPost postTmp
        err = pp.Collection.FindOneAndUpdate(ctx, filter, update, opts).Decode(&amp;tmpPost)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, domain.PostNotFoundError
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, op)</span>
        }

        <span class="cov0" title="0">return tmpPost.ToPost(), nil</span>
}

func (pp *PostRepoMongo) Unvote(ctx context.Context, PostId string) (*post.Post, error) <span class="cov0" title="0">{
        const op = "Unvote"
        userID, ok := ctx.Value("UserID").(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("cannot cast userID to string")
        }</span>

        <span class="cov0" title="0">objID, err := bson.ObjectIDFromHex(PostId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid post ID: %w", err)
        }</span>
        <span class="cov0" title="0">filter := bson.M{
                "_id": objID,
        }

        update := bson.M{
                "$pull": bson.M{
                        "votes": bson.M{
                                "user": userID,
                        },
                },
        }

        // Опции для возврата обновлённого документа
        opts := options.FindOneAndUpdate().SetReturnDocument(options.After)

        var tmpPost postTmp
        err = pp.Collection.FindOneAndUpdate(ctx, filter, update, opts).Decode(&amp;tmpPost)

        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("post with ID %s not found", PostId)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">ReturnedPost := tmpPost.ToPost()

        return ReturnedPost, nil</span>
}

// UpdateScore calculates the sum of votes.vote and updates the score field
func (pp *PostRepoMongo) UpdateScore(ctx context.Context, PostId string) (*post.Post, error) <span class="cov0" title="0">{
        const op = "UpdateScore"

        // Convert postID to ObjectID
        objID, err := bson.ObjectIDFromHex(PostId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        // Fetch the post
        <span class="cov0" title="0">var tmpPost postTmp
        err = pp.Collection.FindOne(ctx, bson.D{{Key: "_id", Value: objID}}).Decode(&amp;tmpPost)
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("post with ID %s not found", PostId)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        // Calculate score by summing votes.vote
        <span class="cov0" title="0">updatedScore := 0
        for _, vote := range tmpPost.Votes </span><span class="cov0" title="0">{
                updatedScore += vote.VoteScore
        }</span>

        // Update the score in MongoDB
        <span class="cov0" title="0">_, err = pp.Collection.UpdateOne(ctx, bson.D{{Key: "_id", Value: objID}}, bson.D{
                {Key: "$set", Value: bson.D{{Key: "score", Value: updatedScore}}},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>

        // Update the post object
        <span class="cov0" title="0">tmpPost.Score = updatedScore
        ReturnedPost := tmpPost.ToPost()
        return ReturnedPost, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package postgres

import (
        "context"
        "fmt"
        "time"

        "github.com/VladislavYak/redditclone/pkg/domain/auth"
        "github.com/go-faster/errors"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

var _ auth.AuthRepository = new(AuthRepoPostgres)

type AuthRepoPostgres struct {
        Pool *pgxpool.Pool
}

func NewAuthRepoPostgres(pool *pgxpool.Pool) *AuthRepoPostgres <span class="cov0" title="0">{
        return &amp;AuthRepoPostgres{Pool: pool}
}</span>

func (a *AuthRepoPostgres) AddJWT(ctx context.Context, Token string, UserID string, IssuedAt time.Time, ExpiresAt time.Time) error <span class="cov0" title="0">{
        const op = "AddJWT"
        fmt.Println("before Add JWT")

        fmt.Println("")
        _, err := a.Pool.Exec(ctx,
                "INSERT INTO sessions (user_id, token, issued_at, expires_at) VALUES ($1, $2, $3, $4)",
                UserID, Token, IssuedAt, ExpiresAt,
        )

        fmt.Println("errrrrr", err)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// INSERT INTO sessions (user_id, token, issued_at, expires_at) VALUES
// (1, 'sample_jwt_token_1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP + INTERVAL '1 hour'),
// (2, 'sample_jwt_token_2', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP + INTERVAL '1 hour');

func (a *AuthRepoPostgres) ValidateJWT(ctx context.Context, Token string, ExpiresAt time.Time) error <span class="cov0" title="0">{
        const op = "ValidateJWT"
        fmt.Println("inside ValidateJWT")
        var expiresAt time.Time
        err := a.Pool.QueryRow(ctx, "select expires_at from sessions where token = $1", Token).Scan(&amp;expiresAt)

        if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                return errors.New("token not found")
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, op)
        }</span>

        <span class="cov0" title="0">fmt.Println("я тут")

        if expiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return auth.ExpiredTokenError
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package postgres

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
)

func NewPgPool() (*pgxpool.Pool, error) <span class="cov0" title="0">{
        connStr := "postgres://postgres:love@localhost:5432/golang?sslmode=disable"

        Pool, err := pgxpool.New(context.Background(), connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := Pool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                fmt.Println("i was here NewPgPool")
                fmt.Println("errr", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">fmt.Println("connected to pg")

        return Pool, nil</span>

}
</pre>
		
		<pre class="file" id="file23" style="display: none">package postgres

import (
        "context"
        "fmt"

        "github.com/go-faster/errors"

        "github.com/VladislavYak/redditclone/pkg/domain/user"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

var _ user.UserRepository = new(UserRepoPostgres)

type UserRepoPostgres struct {
        Pool *pgxpool.Pool
}

func NewUserRepoPostgres(pool *pgxpool.Pool) *UserRepoPostgres <span class="cov0" title="0">{
        return &amp;UserRepoPostgres{Pool: pool}
}</span>

func (r *UserRepoPostgres) GetUser(ctx context.Context, User *user.User) (*user.User, error) <span class="cov0" title="0">{
        const op = "GetUser"

        var u user.User
        err := r.Pool.QueryRow(ctx, "SELECT id, login, password FROM users WHERE login = $1", User.Username).
                Scan(&amp;u.UserID, &amp;u.Username)
        if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                return nil, user.UserNotExistsError
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>
        <span class="cov0" title="0">return &amp;u, nil</span>
}

func (r *UserRepoPostgres) Create(ctx context.Context, User *user.User, Password string) (*user.User, error) <span class="cov0" title="0">{
        const op = "Create"

        fmt.Println("before insertion Create")

        err := r.Pool.QueryRow(ctx,
                "INSERT INTO users (login, password) VALUES ($1, $2) RETURNING id",
                User.Username, Password,
        ).Scan(&amp;User.UserID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, op)
        }</span>
        <span class="cov0" title="0">return User, nil</span>
}

func (r *UserRepoPostgres) GetUserPassword(ctx context.Context, user *user.User) (string, error) <span class="cov0" title="0">{
        const op = "GetUserPassword"

        var Password string
        err := r.Pool.QueryRow(ctx, "select password from users where username = $1", user.Username).Scan(Password)
        if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                return "", errors.New("user not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, op)
        }</span>
        <span class="cov0" title="0">return Password, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package ram

import (
        "context"
        "errors"
        "strconv"
        "sync"

        "github.com/VladislavYak/redditclone/pkg/domain/comment"
        "github.com/VladislavYak/redditclone/pkg/domain/post"
)

var _ comment.CommentRepository = new(CommentRepo)

type CommentRepo struct {
        Data []*post.Post
        *sync.Mutex
        lastID    int
        commentID int
}

func NewCommentRepo() *CommentRepo <span class="cov0" title="0">{
        return &amp;CommentRepo{}
}</span>

func (pp *CommentRepo) AddComment(ctx context.Context, Id string, comment *comment.Comment) error <span class="cov0" title="0">{
        // add more mutexes handling
        pp.Mutex.Lock()
        defer pp.Mutex.Unlock()

        for _, Post := range pp.Data </span><span class="cov0" title="0">{
                if Post.Id == Id </span><span class="cov0" title="0">{
                        Post.Comments = append(Post.Comments, *comment.WithId(strconv.Itoa(pp.commentID)))

                        pp.commentID++
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return errors.New("post not found")</span>
}

func (pp *CommentRepo) DeleteComment(ctx context.Context, id string, commentId string) error <span class="cov0" title="0">{

        pp.Mutex.Lock()
        defer pp.Mutex.Unlock()
        for i, post := range pp.Data </span><span class="cov0" title="0">{
                if post.Id == id </span><span class="cov0" title="0">{

                        for j, comment := range post.Comments </span><span class="cov0" title="0">{
                                if comment.Id == commentId </span><span class="cov0" title="0">{
                                        post.Comments = append(post.Comments[:j], post.Comments[j+1:]...)
                                        pp.Data[i] = post
                                        return nil
                                }</span>

                        }

                }

        }
        <span class="cov0" title="0">return errors.New("this id doesnot exist")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package ram

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "sync"

        "github.com/VladislavYak/redditclone/pkg/domain/post"
)

var _ post.PostRepository = new(PostRepo)

type PostRepo struct {
        Data []*post.Post
        *sync.Mutex
        lastID    int
        commentID int
}

func NewPostRepo() *PostRepo <span class="cov0" title="0">{
        return &amp;PostRepo{
                []*post.Post{},
                &amp;sync.Mutex{},
                0,
                0,
        }
}</span>

func (pp *PostRepo) GetAllPosts(ctx context.Context) ([]*post.Post, error) <span class="cov0" title="0">{
        return pp.Data, nil
}</span>

func (pp *PostRepo) GetPostsByCategoryName(ctx context.Context, CategoryName string) ([]*post.Post, error) <span class="cov0" title="0">{
        res := []*post.Post{}

        for _, post := range pp.Data </span><span class="cov0" title="0">{
                if post.Category == CategoryName </span><span class="cov0" title="0">{
                        res = append(res, post)
                }</span>
        }
        <span class="cov0" title="0">return res, nil</span>

}

func (pp *PostRepo) GetPostByID(ctx context.Context, ID string) (*post.Post, error) <span class="cov0" title="0">{
        for _, post := range pp.Data </span><span class="cov0" title="0">{
                if post.Id == ID </span><span class="cov0" title="0">{
                        return post, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New("not found")</span>
}

func (pp *PostRepo) GetPostsByUsername(ctx context.Context, Username string) ([]*post.Post, error) <span class="cov0" title="0">{
        res := []*post.Post{}

        for _, post := range pp.Data </span><span class="cov0" title="0">{
                if post.Author.Username == Username </span><span class="cov0" title="0">{
                        res = append(res, post)
                }</span>
        }
        <span class="cov0" title="0">return res, nil</span>

}

func (pp *PostRepo) AddPost(ctx context.Context, Post *post.Post) (*post.Post, error) <span class="cov0" title="0">{
        // pretty random handling mutexes
        pp.Mutex.Lock()
        defer pp.Mutex.Unlock()

        Post = Post.WithId(strconv.Itoa(pp.lastID))

        pp.lastID++

        pp.Data = append(pp.Data, Post)

        fmt.Println("my Posts", pp.Data)
        return Post, nil
}</span>

func (pp *PostRepo) DeletePost(ctx context.Context, Id string) (*post.Post, error) <span class="cov0" title="0">{
        for i, value := range pp.Data </span><span class="cov0" title="0">{
                if value.Id == Id </span><span class="cov0" title="0">{
                        pp.Data = append(pp.Data[:i], pp.Data[i+1:]...)
                }</span>
                <span class="cov0" title="0">return value, nil</span>
        }

        <span class="cov0" title="0">return nil, errors.New("this id doesnot exist")</span>

}

// yakovlev: add proper error handling

func (pp *PostRepo) Vote(ctx context.Context, PostId string, Vote int) (*post.Post, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// func (pp *PostRepo) Upvote(ctx context.Context, PostId string) (*post.Post, error) {
//         pp.Mutex.Lock()
//         defer pp.Mutex.Unlock()

//         UserId, ok := ctx.Value("UserID").(string)
//         if !ok {
//                 return nil, errors.New("cannot cast userID to string")
//         }

//         for i, Post := range pp.Data {
//                 if Post.Id == PostId {
//                         for j, voteIter := range Post.Votes {
//                                 if voteIter.User == UserId {

//                                         pp.Data[i].Votes[j].WithVote(1)

//                                         pp.UpdateScore(ctx, Post.Id)
//                                         // pp.Data[i].UpdateScore()
//                                         return pp.Data[i], nil
//                                 }
//                         }

//                         pp.Data[i].Votes = append(pp.Data[i].Votes, post.Vote{User: UserId, VoteScore: 1})
//                         // Post.Votes = append(Post.Votes, Vote{User: user_id, VoteScore: -1})

//                         pp.UpdateScore(ctx, Post.Id)

//                         return pp.Data[i], nil
//                 }
//         }

//         return nil, errors.New("this PostId doesnot exist")
// }

// func (pp *PostRepo) Downvote(ctx context.Context, id string) (*post.Post, error) {
//         pp.Mutex.Lock()
//         defer pp.Mutex.Unlock()

//         UserId, ok := ctx.Value("UserID").(string)
//         if !ok {
//                 return nil, errors.New("cannot cast userID to string")
//         }

//         for i, Post := range pp.Data {
//                 if Post.Id == id {
//                         for j, voteIter := range Post.Votes {
//                                 if voteIter.User == UserId {

//                                         pp.Data[i].Votes[j].WithVote(-1)
//                                         pp.UpdateScore(ctx, Post.Id)
//                                         return pp.Data[i], nil
//                                 }
//                         }

//                         pp.Data[i].Votes = append(pp.Data[i].Votes, post.Vote{User: UserId, VoteScore: -1})
//                         // Post.Votes = append(Post.Votes, Vote{User: user_id, VoteScore: -1})

//                         pp.UpdateScore(ctx, Post.Id)

//                         return pp.Data[i], nil
//                 }
//         }

//         return nil, errors.New("this id doesnot exist")
// }

func (pp *PostRepo) Unvote(ctx context.Context, id string) (*post.Post, error) <span class="cov0" title="0">{
        pp.Mutex.Lock()
        defer pp.Mutex.Unlock()

        UserId, ok := ctx.Value("UserID").(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("cannot cast userID to string")
        }</span>

        <span class="cov0" title="0">for i, Post := range pp.Data </span><span class="cov0" title="0">{
                if Post.Id == id </span><span class="cov0" title="0">{
                        for j, voteIter := range Post.Votes </span><span class="cov0" title="0">{
                                if voteIter.User == UserId </span><span class="cov0" title="0">{

                                        pp.Data[i].Votes = append(pp.Data[i].Votes[:j], pp.Data[i].Votes[j+1:]...)
                                        pp.UpdateScore(ctx, Post.Id)
                                        return pp.Data[i], nil
                                }</span>
                        }

                        <span class="cov0" title="0">return nil, errors.New("cannot find user for specified post")</span>
                }
        }

        <span class="cov0" title="0">return nil, errors.New("this id doesnot exist")</span>
}

func (pp *PostRepo) UpdateScore(ctx context.Context, Id string) (*post.Post, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package ram

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "sync"
        "time"

        "github.com/VladislavYak/redditclone/pkg/domain/user"
)

var _ user.UserRepository = new(UserRepo)

type UserRepo struct {
        Users *[]user.User
        *sync.Mutex
        lastID int
}

func NewUserRepo() *UserRepo <span class="cov0" title="0">{
        return &amp;UserRepo{
                &amp;[]user.User{},
                &amp;sync.Mutex{},
                0,
        }
}</span>

func (ur *UserRepo) Create(ctx context.Context, User *user.User, Password string) (*user.User, error) <span class="cov0" title="0">{
        ur.Mutex.Lock()
        defer ur.Mutex.Unlock()

        fmt.Println("ur.Users AddUser", ur.Users)
        if ur.isUserExists(User) </span><span class="cov0" title="0">{
                return nil, errors.New("this user already exists")
        }</span>

        <span class="cov0" title="0">idStr := strconv.Itoa(ur.lastID)

        User = User.WithID(idStr)

        ur.lastID++

        *ur.Users = append(*ur.Users, *User)

        fmt.Println("users", ur.Users)
        return User, nil</span>

}

func (ur *UserRepo) isUserExists(user *user.User) bool <span class="cov0" title="0">{

        fmt.Println("ur.Users")
        fmt.Printf("isUserExists ur.Users %+v\n", ur.Users)
        for _, userIter := range *ur.Users </span><span class="cov0" title="0">{
                if userIter.Username == user.Username </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (ur *UserRepo) GetUser(ctx context.Context, user *user.User) (*user.User, error) <span class="cov0" title="0">{
        fmt.Println("inside GetUser, before loop")
        fmt.Printf("in use %+v\n", user)
        fmt.Printf("ur.Users %+v\n", ur.Users)
        for _, userIter := range *ur.Users </span><span class="cov0" title="0">{
                fmt.Println("userIter", userIter)
                fmt.Printf("userIter %+v\n", userIter)
                if user.Username == userIter.Username </span><span class="cov0" title="0">{
                        return &amp;userIter, nil
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("inside GetUser after loop")

        return nil, errors.New("user not found")</span>
}

func (ur *UserRepo) GetUserPassword(ctx context.Context, user *user.User) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (r *UserRepo) AddJWT(context.Context, string, string, time.Time, time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

func (r *UserRepo) ValidateJWT(ctx context.Context, Token string, expiredAt time.Time) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
